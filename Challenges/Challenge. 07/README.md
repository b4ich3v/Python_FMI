* Това предизвикателство е с краен срок чак на Коледа. Пускаме го отсега, за да можете да решите дали да го решите сега, успоредно с 
  домашното, по време на ваканцията, или никога. Не планувахме да правим такова, но вчера поискахте - днес даваме.
  За празниците сме подготвили баница. Баницата е осем-измерна и е нарязана така, че всяко измерение има 2 реда, 2 колони, или както там 
  решите да наречем линиите от дадено измерение. Общо 256 парчета. В едно от парчетата има паричка.

* Осемизмерен куб (октеракт) е проста концепция, но трудно се визуализира в две измерение. Това е апроксимация на това как би изглеждала 
  октерактна баница с късмети. Вашата задача е да напишете функция lucky, която да връща адреса на парчето с паричка. Очакваме адресът да е 
  цяло число (int) от 0 до 255, което представено в двоичен код представлява адрес в осем-мерната баница, на който е паричката.

  Например, ако функцията върне 42, неговата репрезентация в двоична система е 101010. За да довършим адреса допълваме до 8-битово число, като 
  запълним левите битове с нули: 00101010. Това е адресът в баницата, който смятате, че крие паричката. Всеки бит от числото показва позиция в 
  един от осемте разреза, които са направени, за да се разреже баницата.

  За да определите къде е късмета, можете да извикате една функция, която да ви помогне. Функцията се казва clue и се намира в модул secret. 
  Можете да я импортирате с from secret import clue.

  Имате право да извикате функцията clue само 4 пъти. Всяко извикване може да се направи с един от 4 именувани аргумента, като всеки аргумент 
  може да се ползва само веднъж. Нямате право да викате функцията повече от веднъж с даден аргумент. Вариантите са следните:

* left_shift - извиквате функцията с именуван аргумент left_shift, чията очаквана стойност е цяло число не по-малко от 5. Функцията ще върне 
  цяло число, което се получава като резултат от адреса с късмета, след прилагане на побитовото изместване в ляво с подадения брой позиции. 
  Досещате се, че след като изместим адреса в ляво, се получават повече от 8 бита. След изместването на адреса, той отново се свежда до 8 
  бита, като всичко след най-десните 8 отпада. Например:

  Адресът с късмет е 42 (00101010)
  clue(left_shift=6)  # 128
  00101010 изместено в ляво с 6 бита е 101010000000
  взимат се само на-десните 8 бита - 10000000
  10000000 e двоичен запис за 128
  
* right_shift - извиквате функцията с именуван аргумент right_shift, чията очаквана стойност е цяло число не по-малко от 5. Функцията ще върне 
  цяло число, което се получава като резултат от адреса с късмета, след прилагане на побитовото изместване в дясно с подадения брой позиции. 
  Тук няма опасност да се получат повече от 8 бита. Например:

  Адресът с късмет е 42 (00101010)
  clue(right_shift=5)  # 1
  00101010 изместено в дясно с 5 бита е 001
  001 e двоичен запис за 1
  
* bw_and - извиквате функцията с именуван аргумент bw_and, чията очаквана стойност е цяло число, чиято двоична репрезентация съдържа не повече 
  от една единица. Функцията ще върне цяло число, което се получава като резултат от адреса с късмета, след прилагане на побитовото AND с 
  подаденото цяло число. Например:

  Адресът с късмет е 42 (00101010)
  clue(bw_and=8)  # 8
  8 се репрезентира като 1000
  прилагане на битово AND между 1000 и 00101010 дава 00001000, което е 8 в десетична система
  
* bw_or - извиквате функцията с именуван аргумент bw_or, чията очаквана стойност е цяло число, чиято двоична репрезентация съдържа не повече 
  от една нула. Функцията ще върне цяло число, което се получава като резултат от адреса с късмета, след прилагане на побитовото OR с 
  подаденото цяло число. Например:

  Адресът с късмет е 42 (00101010)
  clue(bw_or=223)  # 255
  223 се репрезентира като 11011111
  прилагане на битово OR между 11011111 и 00101010 дава 11111111, което е 255 в десетична система
  Ако извикате функцията clue с даден позиционен аргумент повече от веднъж, ще се възбуди някакво изключение. Същото важи и ако не спазите 
  специалните правила за стойностите зад именуваните аргументи (поне 5 позиции за шифтване и не повече от 1 нула/единица съответно за OR/AND 
  аргументите). Дори да извикате функцията с невалидна стойност зад даден аргумент, което ще породи изключение, това се брои за извикване, 
  така че няма да имате право да извикате функцията пак с друга стойност зад този аргумент.

  Във всички примери адресът на късмета е 42, така че се очаква вашата функция да върне 42:
