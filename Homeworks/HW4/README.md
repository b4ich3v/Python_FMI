* Напишете 5 класа, които репрезентират материали, с които може да се строи стена:

  Concrete
  Brick
  Stone
  Wood
  Steel
  Всеки от класове има идентична сигнатура. При инстанциране приема един позиционен аргумент от тип int, който указва масата на създадения материал.
  Всеки от класовете има дефинирана плътност. Тя е различна за всеки материал:

  Concrete = 2500
  Brick = 2000
  Stone = 1600
  Wood = 600
  Steel = 7700
  Всяка инстанция от класовете за материал трябва да има пропърти volume за изчисление на обема си.
  Обемът е равен на масата, разделена на плътността. Очаква се резултатът да е от тип float.

  brick = Brick(2000)
  print(brick.volume)  # 1.0
  Лесно, нали? Brace yourselves!

* Фабрика
  Напишете клас Factory, който репрезентира фабрика за производство на материали.
  Класът може да се инстанцира без аргументи, като резултат е една конкретна фабрика за материали. Можем да правим много фабрики.

  factory = Factory()
  Инстанциите от тип Factory трябва да могат да бъдат извиквани, т.е. да са callable.
  Извикването може да се случи по два начина - само с произволен брой именувани аргументи или само с произволен брой позиционни. Не можем да извикваме инстанцията 
  със смесица от позиционни и именувани. Не можем да я извикаме и без аргумент.
  Ако се опитаме да приложим някой от тези два случая, очакваме да се върне ValueError с произволен текст.

  factory = Factory()
  factory()  # ValueError
  factory(obj1, name=obj2)  # ValueError
  Извикване с именувани аргументи
  Ако извикате инстанция на Factory с произволен брой именувани аргументи, очаква се имената им да съвпадат с един от класовете за материали дефинирани по-горе 
  (или имена на динамично създадени материали, за които ще поговорим по-долу).
  Ако получите именуван аргумент с друго име - ValueError с произволен текст. Очакваната стойност зад името на всеки именуван аргумент е масата за съответния 
  материал, т.е. int. Няма да тестваме с невалидни стойности зад имената.
  Очаква се да върнете като резултат tuple, който съдържа по една инстанция, създадена от съответния клас, имаща съответната маса. Редът в резултата трябва да 
  съвпада с реда на подадените аргументи. Извикване със само един именуван аргумент е валидно - връщате tuple с един елемент.

  factory = Factory()
  brick, wood = factory(Brick=1000, Wood=5000)
  print(brick.volume)  # 0.5
  print(wood.volume)  # 8.(3)
  Извикване с позиционни аргументи
  Ако извикате инстанция на Factory с произволен брой позиционни аргументи, очаква се аргументите да са инстанции на някой от дефинираните материали (било то 
  петте по-горе, или динамично създадени, за които ще разберете на следващия ред).
  Очаква се да се създаде динамично нов клас, който репрезентира сплав от подадените материали (да, наясно сме, че не всичко може да се смеси в сплав, но думата е 
  удобна, така че я използваме).
  Като резултат, трябва да върнете инстанция на новосъздадения клас. Новият клас трябва да има същата сигнатура като 5-те класа за материал от началото на 
  задачата:

  да очаква маса за инстанциране;
  да има дефинирана плътност;
  да имплементира volume пропърти.
  Плътността на новосъздадения клас трябва да бъде средно аритметично от плътностите на всеки от 5-те оригинални материала, които са използвани за създаването на 
  класа. Виж апендикса.
  Името на класа трябва да е конкатенирана версия на имената на тези от петте класа от по-горе, които са използвани като вход, в азбучен ред, отделени от долна 
  черта.
  Масата на създадената инстанция, трябва да е сума от масите на обектите, които са подадени като вход.
  Ако инстанцията ви бъде извикана няколко пъти с обекти, чиито класове съвпадат (без значение от реда), не очакваме да правите нов клас, тъй като такъв вече сте 
  направили. Просто връщате нова инстанция от вече съществуващия клас. Това важи и за вход от само един елемент (дори той да е един от 5-те в началото). Ако има 
  клас с очакваното име, използвате него. Ако няма, правите нов.
  Приемете, че няма да тестваме с вход, който съдържа повече от едно срещане на някой от 5-те първоначални материали. Т.е. не очаквайте да получите примерно два 
  материала Wood, или комбинация от типа Concrete_Wood и Wood. Всеки от 5-те материала може да се срещне само веднъж.

  factory = Factory()
  brick1, wood1 = factory(Brick=10, Wood=5)
  brick2, wood2 = factory(Brick=20, Wood=15)
  factory(brick1, wood1)  # Инстанция на новосъздаден клас с име "Brick_Wood".
                        # Класът има плътност (2000 + 600) / 2 = 1300.
                        # Инстанцията има маса 15

  factory(brick2, wood2)  # Инстанция на вече съществуващия клас "Brick_Wood".
                        # Инстанцията има маса 35
  Динамично създадени класове, които генерирате при извикване на инстанциите с позиционни аргументи, трябва да са валиден инпут за последващи извиквания на 
  инстанцията, било то в позиционен, или именуван аргумент.

  factory = Factory()
  brick, wood = factory(Brick=10, Wood=5)
  concreate, = factory(Concrete=10)
  brick_wood = factory(brick, wood)

  another_brick_wood, = factory(Brick_Wood=10)  # Валидно инстанциране на ново парче сплав с маса 10 и тип Brick_Wood, който е създаден на предишния ред

  brick_concrete_wood = factory(brick_wood, concreate)  # Създава нов клас Brick_Concrete_Wood
                                                      # Плътността на класа е (2000 + 2500 + 600) / 3 = 1700
                                                      # Масата на инстанцията е 25
  Логично е след като фабриката е използвала дадени инстанции на материали, подадени като позиционни аргументи, за създаване на нова инстанция, входните инстанции 
  да станат неизползваеми. Нека всеки обект, който е подаден като позиционен на инстанция на Factory, да става невалиден. Той продължава да съществува и можете да 
  видите типа му и масата му, но ако го подадете отново на фабрика, да се поражда AssertionError с произволен текст. AssertionError е вграден тип грешка - не е 
  нужно да го дефинирате.

  factory = Factory()
  brick, wood = factory(Brick=10, Wood=5)
  brick_wood = factory(brick, wood)
  brick_wood = factory(brick, wood)  # AssertionError
  А стената?
  Като за десерт, трябва да можем да проверим дали материалите, които са създадени от дадена фабрика, са достатъчно за изграждане на стена с конкретен обем. 
  Имплементирайте метод can_build, който приема един позиционен аргумент от тип int и връща булева стойност, в зависимост от това дали материалите, създадени от 
  конкретната фабрика, са достатъчно. Не ни интересуват обекти, които са създадени извън инстанцията, върху която извикваме can_build.
  Изчисленията включват както материали, създадени с позиционни аргументи, така и материали, създадени с именувани. Не включваме материали, които са преизползвани 
  (подавани на фабрика като позиционни), защото те са невалидни.

  factory = Factory()
  brick, wood = factory(Brick=2000, Wood=1200)
  print(brick.volume)  # 1.0
  print(wood.volume)  # 2.0
  print(factory.can_build(3))  # True
  print(factory.can_build(4))  # False
  Много фабрики?
  Да, можем да създаваме много фабрики. Ако даден материал е направен с една фабрика, той може да се подава на друга фабрика.
  Ако дадена сплав е създадена от една фабрика, другите фабрики трябва да са наясно за този технологичен скок и да преизползват вече създадения клас за тази сплав.

  factory1 = Factory()
  factory2 = Factory()
  brick1, wood1 = factory1(Brick=1, Wood=2)
  brick2, wood2 = factory2(Brick=1, Wood=2)
  brick_wood1 = factory1(brick1, wood1)  # Създава нов клас "Brick_Wood" и връща инстанция от него
  brick_wood2 = factory2(brick2, wood2)  # Използва съществуващия клас "Brick_Wood" и връща инстанция от него
  print(type(brick_wood1) is type(brick_wood2))  # True
  Правилото, че не можем да преизползваме материали, ако сме направили от тях друг материал, важи и тук.

  factory1 = Factory()
  factory2 = Factory()
  brick, wood = factory1(Brick=1, Wood=2)

  brick_wood = factory1(brick, wood)
  factory2(brick, wood)  # AssertionError
  Can build?
  И последно. Искаме да можем да видим дали материалите, създадени (и не преизползвани) от всички фабрики са достатъчно за изграждане на стена. Оценката се случва 
  спрямо обемите на въпросните материали.
  Ако методът can_build е извикан на инстанция, той проверява само материалите направени с тази инстанция.
  Ако извикаме метод can_build_together на класа Factory, проверява всички материали създадени (и не преизползвани) от всички инстанции.

  factory1 = Factory()
  brick1, wood1 = factory1(Brick=2000, Wood=1200)
  print(brick1.volume)  # 1.0
  print(wood1.volume)  # 2.0
  brick_wood1 = factory1(brick1, wood1)
  print(brick_wood1.volume)  # 2.46
  print(factory1.can_build(3))  # False

  factory2 = Factory()
  brick2, wood2 = factory2(Brick=2000, Wood=1200)
  print(brick2.volume)  # 1.0
  print(wood2.volume)  # 2.0
  brick_wood2 = factory2(brick2, wood2)
  print(brick_wood2.volume)  # 2.46
  print(factory2.can_build(3))  # False

  print(Factory.can_build_together(3))  # True
  Апендикс за изчисляване на нова плътност
  Ако имате два материала, например Wood и Concrete, и ги обедините в сплав, плътността на новия материал е (2500 + 600) / 2 = 1550.
  Ако към тази сплав добавите и Steel, плътността не може да се изчисли като средно аритметично от Concrete_Wood и Steel, защото те имат различно съотношение.
  Такава сметка би дала резултат (1550 + 7700) / 2 = 4625. Това е грешно.
  Правилната сметка трябва да направите като използвате трите основни материала, които са използвани:
  (density of Concrete + density of Steel + density of Wood) / 3.
  (2500 + 7700 + 600) / 3 = 3600.
