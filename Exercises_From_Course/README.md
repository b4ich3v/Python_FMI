1. Да се направи обект n-мерна mutable матрица, която да позволява индексиране чрез n-торка.
   
*  Инициализация- При инициализация на матрицата се подават кортеж с дължина измеренията на матрицата. Всеки от неговите елементи указва дълбочината на матрицата във въпросната посока. При инициализация матрицата се запълва с нули.
  
*  Индексиране- Достъп до матрицата може да се осъществи чрез кортеж, представляващ вектор, който описва координатите на даден елемент. Бонус точка
  
*  Искаме да можем да "слайсваме" матрицата по дадени 2 точки, които чрез ортогонална на измеренията на матрицата проекция се пресичат и дефинират даден отсек от матрицата.
   
2. Да се направят два декоратора @чекай и @ептем_чекай, които да работят върху следния код:

*  @чекай:
  
   Декораторът приема един аргумент, който е време в секунди. Когато декориран метод се изпълни, неговият индивидуален таймер започва да тече и ако има опът методът да бъде изпълнен отново преди да изминат толкова секунди, се възбужда 
   грешка КуртолисайСе с текст "<име_на_метода> - оста'ат още <секунди> секунди, баце!".

*  @ептем_чекай:
  
   Декораторът е "глобален" таймер, който важи за всички методи, които са декорирани с него. Той има времетраене 3 секунди и методи, които са декорирани с @ептем_чекай не могат да бъдат изпълнявани докато тече глобалният cooldown. Грешката, 
   която трябва да се хвърли е отново КуртолисайСе, но с текст "Запри се, баце, оста'ат още <секунди> секунди!".

*  Забележка: Всички текстове подлежат на промяна спрямо личното творчество на авторът, стига той да е автентичен обитател на митичните ширини, по които се развива нашият епос.

3. Искаме да създадем функция, която ще добавя числа заедно, когато се извикват последователно. Ние също така искаме да можем да продължим да добавяме числа към нашата верига. Едно извикване трябва да е равно на предаденото число. Трябва да    можем да съхраняваме върнати стойности и ги използвайте повторно.

4. Да се напише декоратор @optimizer, който да оптимизира функция за изчисляване на числата на Фибоначи чрез кеширане. Този декоратор трябва да съхранява вече изчислените стойности и да ги използва, когато е необходимо, за да намали времето    за изчисление при повторни извиквания на функцията с еднакви аргументи.

5. Представи си, че наследяваш клас и често се налага да презаписваш методи от родителя, но все пак да извикаш и оригиналните, дефинирани в него:
   Би било полезно да можеш да си го спестиш. Напиши декоратор lazy_super, който автоматично извиква метода на родителя, подавайки същите аргументи, които са подадени към метода на детето.
   Нека декораторът приема опционален именуван параметър rewrite_return, с който можеш да контролираш дали декорираният методът да върне това, което е дефинирано в неговото тяло, или това, което връща родителския метод. При True - родителския. При False - този на детето.
